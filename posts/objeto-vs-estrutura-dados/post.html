<!--:::{
  "post_title": "Objeto Vs. Estrutura de Dados - Clean Code",
  "post_description": "O que o Clean Code tem a dizer sobre o uso de estrutura de dados.",
  "post_created_at": "Mon Aug 29 2022 16:16:55 GMT-0300 (Horário Padrão de Brasília)"
}:::-->

<article id="293688d4-4d04-4b5e-9c48-8edee2a2705a" class="page sans">
	<div class="page-body">
		<p id="c0fb93d9-d9e6-450f-bd71-99ccc973473f" class="">
			Vejo muito no Linkedin posts sobre “dicas de Clean Code”, e apesar de
			muito úteis, sempre trazem o mesmo conteúdo: como nomear funções e
			variáveis, evitar comentários e um pouco sobre o princípio de
			responsabilidade única.
		</p>
		<p id="09c7fe92-57e7-4fa5-a903-bb9dae8c63d4" class="">
			É verdade que esses são os assuntos dos primeiros capítulos do livro do
			Uncle Bob, mas ele vai bem além desses aspectos. E eu vou tentar trazer
			sobre o início do 6° capítulo, que trata sobre o título deste artigo e
			que me interessou muito.
		</p>
		<p id="60fdce90-6568-4ac3-81f6-bbbe782a8038" class="">
			Mas afinal, qual a diferença entre data objetos e estruturas de dados?
			E a resposta que o livro traz é: <em><q>Os objetos usam abstrações para
			esconder seus dados, e expõem as funções que operam em tais dados. As
			estruturas de dados expõem seus dados e não possuem funções
			significativas.</q></em>
		</p>
		<p id="10492664-e569-4685-b4b4-46a97f8fd388" class="">
			Essa explicação por si só já é muito boa na minha opinião. Mas vamos
			ver exemplos em C#:
		</p>
		<pre
			id="6a4dcd93-f076-4a1e-b818-64c2662c99c7"
			class="code"
		><code>public class Quadrado
  {
      public double Lado { get; set; }
  }
  
  public class Circulo
  {
      public double Raio { get; set; }
  }
  
  public class Geometria
  {
      public const double Pi = 3.141592;
  
      public double Area(Object forma)
      {
          if (forma is Quadrado)
          {
              Quadrado s = (Quadrado)forma;
              return s.Lado * s.Lado;
          }
          
          Circulo c = (Circulo)forma;
          return Pi * c.Raio * c.Raio;
      }
  }</code></pre>
		<p id="f2ae9af6-2270-49af-bcf7-f89069e12277" class="">
			No exemplo acima, as classes Quadrado e Circulo são simples estruturas
			de dados e todos os métodos estão na classe Geometria. E o paradigma
			usado no exemplo foi o procedural. Ok, e como seria essa solução
			orientada a objeto?
		</p>
		<pre
			id="65139fda-55db-47ca-ac7a-535024bb2d58"
			class="code"
		><code>public class Quadrado : Forma
  {
    private double Lado { get; set; }
  
    public double Area()
    {
      return Lado * Lado;
    }
  }
  
  public class Circulo : Forma
  {
    private double Raio { get; set; }
    public const Pi = 3.141592;
  
    public double Area()
    {
      return Pi * Raio * Raio;
    }
  }</code></pre>
		<p id="aee76a0c-bce0-4208-a838-7726b6e087c1" class="">
			Já nesse segundo exemplo, tanto Quadrado quanto Circulo são objetos,
			pois escondem seus dados e expõem seus métodos.
		</p>
		<p id="87332a85-da78-4085-a544-822aba54f8c7" class="">
			E dado esses exemplos, qual a principal diferença entre eles, e
			principalmente, qual a relação disso tudo com o Clean Code?
		</p>
		<p id="ce8d2f93-7e7f-4cf5-b477-4de921bb4aba" class="">
			A principal diferença no paradigma <strong>procedural</strong>, usando
			estruturas de dados (primeiro exemplo), ao adicionar um novo método na
			classe Geometria, as classes Quadrado e Circulo (e qualquer outra
			classe de forma geométrica que tivéssemos) não precisariam sofrer
			qualquer alteração. Muito bom, certo? Com certeza. Mas por outro lado
			se adicionássemos uma nova classe de forma geométrica, precisaríamos
			alterar todos os métodos da classe Geometria.
		</p>
		<p id="dbb78528-8268-48f2-9031-b76dd530e743" class="">
			Agora no código<strong> orientado a objeto</strong> (segundo exemplo) o
			oposto acontece. Por conta do polimorfismo do método
			<code>Area()</code> , a adição de novas classes de forma geométrica se
			torna bem fácil. Porém, para se adicionássemos um novo método, todas as
			classes de forma geométrica precisariam ser alteradas.
		</p>
		<p id="c4c6a141-de87-4003-ac78-22c069677792" class="">
			Concluindo, o que o Clean Code diz sobre tudo isso? Quando formos
			desenvolver um sistema, às vezes, desejaremos facilidade para adicionar
			novos tipos de dados, e, então usaremos objetos. Outras vezes,
			desejaremos facilidade para adicionar novos métodos, e, então usaremos
			estruturas de dados. Portanto cabe ao bom desenvolvedor, sem
			preconceito entre POO e procedural, identificar qual a melhor abordagem
			para se usar no dado momento.
		</p>
		<p id="e109aaf3-fdc4-4b25-beb6-f32b2a18cc2b" class=""></p>
		<p id="fdca9e90-d3cd-44aa-b9ac-210f7f6b8c7b" class="">
			Importante: O capítulo abordado, Objetos e Estruturas de Dados, traz
			também sobre A lei de Demeter, Train Wreks, Estruturas Híbridas,
			Estruturas Ocultas, DTOs e Active Records, que complementam o que foi
			abordado neste texto.
		</p>
		<p id="750d1614-81a3-426b-bc8f-13fa1f30a148" class=""></p>
		<p id="86c8e28c-0d5a-4f47-91ac-9a98456f3108" class="">
			Exemplos e texto adaptados e interpretados do livro Clean Code, de
			Robert C. Martin.
		</p>
	</div>
</article>
